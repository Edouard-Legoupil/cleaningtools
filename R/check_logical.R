# WARNING - Generated by {fusen} from dev/function_documentation.Rmd: do not edit by hand

#' Check a logical test
#'
#' @param dataset dataset to be check as a dataframe or a list with the dataframe stored as
#' "checked_dataset"
#' @param uuid_column uuid column in the dataset. Default is "uuid".
#' @param information_to_add string vector optional, if to add some information to the log
#' (today, vilagge)
#' @param check_id name of the check to perform
#' @param check_to_perform test to perform as R code (in text format)
#' @param columns_to_clean variables to be put in the log. if not provided, it will try to detect
#' variables
#' @param description description of the check performed
#'
#' @return return a list with the dataset checked stored as checked_dataset, it will have all
#' a column added with the check_id  and a dataframe with the logical check log.
#' @export
#' @examples
#'
#' test_data <- data.frame(
#'   uuid = c(1:10) %>% as.character(),
#'   today = rep("2023-01-01", 10),
#'   location = rep(c("villageA", "villageB"), 5),
#'   distance_to_market = c(rep("less_30", 5), rep("more_30", 5)),
#'   access_to_market = c(rep("yes", 4), rep("no", 6)),
#'   number_children_05 = c(rep(c(0, 1), 4), 5, 6) )
#'  
#' check_logical(test_data,
#'   uuid_column = "uuid",
#'   check_id = "my_test",
#'   check_to_perform = "distance_to_market == \"less_30\" & access_to_market == \"no\"",
#'   columns_to_clean = "distance_to_market, access_to_market",
#'   description = "distance to market less than 30 and no access") |>
#'   knitr::kable()  
#'  
#' check_logical(test_data,
#'   uuid_column = "uuid",
#'   information_to_add = c("today", "location"),
#'   check_to_perform = "distance_to_market == \"less_30\" & access_to_market == \"no\"",
#'   columns_to_clean = "distance_to_market, access_to_market",
#'   description = "distance to market less than 30 and no access")|>
#'   knitr::kable()  

check_logical <- function(dataset,
                          uuid_column = "uuid",
                          information_to_add = NULL,
                          check_id = "logical_xx",
                          check_to_perform,
                          columns_to_clean = NULL,
                          description) {
  if (is.data.frame(dataset)) {
    dataset <- list(checked_dataset = dataset)
  }
  if (!("checked_dataset" %in% names(dataset))) {
    stop("Cannot identify the dataset in the list")
  }

  if (check_id %in% names(dataset[["checked_dataset"]])) {
    msg <- glue::glue(check_id, " is in the names of the dataset, please change check id name.")
    stop(msg)
  }

  if (is.na(description) | description == "") {
    msg <- "description cannot be empty"
    stop(msg)
  }

  if (any(is.null(columns_to_clean), is.na(columns_to_clean), columns_to_clean == "")) {
    msg <- "columns_to_clean not shared, results may not be accurate"
    warning(msg)
    tentative_var <- detect_variable(check_to_perform)
    variables_across_by <- c(tentative_var, information_to_add) %>%
      stringr::str_split(",", simplify = T) %>%
      stringr::str_trim() %>%
      as.vector()
    variables_across_by <- variables_across_by[variables_across_by != ""]
  }

  if (!any(is.null(columns_to_clean), is.na(columns_to_clean), columns_to_clean == "")) {
    variables_across_by <- c(columns_to_clean, information_to_add) %>%
      stringr::str_split(",", simplify = T) %>%
      stringr::str_trim() %>%
      as.vector()
    variables_across_by <- variables_across_by[variables_across_by != ""]
  }

  dataset[["checked_dataset"]] <- dataset[["checked_dataset"]] %>%
    dplyr::mutate(!!rlang::sym(as.character(check_id)) := eval(parse(text = check_to_perform)))

  trimmed_dataset <- dataset[["checked_dataset"]] %>%
    dplyr::filter(!!rlang::sym(check_id)) %>%
    dplyr::mutate(uuid := !!rlang::sym(uuid_column)) %>%
    dplyr::select(dplyr::all_of(c("uuid", variables_across_by)))

  if (exists("tentative_var")) {
    if (length(tentative_var) == 0) {
      dataset[[check_id]] <- trimmed_dataset %>%
        dplyr::mutate(dplyr::across(.cols = dplyr::everything(), .fns = ~ format(., scientific = F, justify = "none", trim = T)),
          question = "unable to identify",
          old_value = "please check this uuid for this check",
          issue = description,
          check_id = check_id,
          check_binding = paste(check_id, uuid, sep = " ~/~ ")
        )
      return(dataset)
    }
  }

  dataset[[check_id]] <- trimmed_dataset %>%
    dplyr::mutate(dplyr::across(.cols = dplyr::everything(), .fns = ~ format(., scientific = F, justify = "none", trim = T))) %>%
    tidyr::pivot_longer(cols = !dplyr::all_of(c("uuid", information_to_add)), names_to = "question", values_to = "old_value") %>%
    dplyr::mutate(
      issue = description,
      check_id = check_id,
      check_binding = paste(check_id, uuid, sep = " ~/~ ")
    )
  return(dataset)
}
